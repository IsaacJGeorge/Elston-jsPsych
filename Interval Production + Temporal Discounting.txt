// Initialize jsPsych
const jsPsych = initJsPsych({
    show_progress_bar: true,
    on_finish: function () {
        jsPsych.endExperiment('The experiment has ended. Thank you!');
        //jsPsych.data.displayData();
    }
});

// function to load the confetti library so that confetti can be used during temporal discounting mwahahahahaha
function loadConfettiLibrary(callback) {
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js';
  script.onload = callback;
  document.head.appendChild(script);
}

// initialize timeline
var timeline = [];

// Function to get or generate participant ID
function getParticipantID() {
  // First check if ID exists in URL parameters (e.g., from Prolific)
  const urlParams = new URLSearchParams(window.location.search);
  let participantID = urlParams.get('PROLIFIC_PID') || urlParams.get('participant_id') || urlParams.get('id');
  
  // If no ID found in URL, check if we've already generated one for this session
  if (!participantID) {
    participantID = sessionStorage.getItem('participant_id');
    
    // If no ID found in session storage, generate a random one
    if (!participantID) {
      // Generate random ID - timestamp + 6 random chars
      const timestamp = new Date().getTime().toString(36);
      const randomChars = Math.random().toString(36).substring(2, 8);
      participantID = `P_${timestamp}_${randomChars}`;
      
      // Store in session storage for consistency within session
      sessionStorage.setItem('participant_id', participantID);
    }
  }
  
  return participantID;
}


// Create HTML stimuli instead of using PNG files
const CLOCK_START_STIMULUS = `
  <div style="width: 150px; height: 150px; border-radius: 50%; border: 10px solid #0000FF; margin: 0 auto;"></div>
`;

const CLOCK_STOP_STIMULUS = `
  <div style="width: 150px; height: 150px; border-radius: 50%; background-color: #0000FF; margin: 0 auto;"></div>
`;

// Preload CSS for the experiment
const preloadTempDiscrim = {
  type: jsPsychPreload,
  images: [] // No images to preload now that we're using HTML stimuli
};

const preloadIntervalProd = {
  type: jsPsychPreload,
  images: []
};

// Preload temporal discounting stimuli
const preloadTempDiscoun = {
  type: jsPsychPreload,
  images: ['img/81PercentGreen_IA.png', 'img/61PercentGreen_IA.png', 'img/41PercentGreen_IA.png',
    'img/21PercentGreen_IA.png', 'img/16SecondDelay_Fractal.png', 'img/8SecondDelay_Fractal.png', 
    'img/4SecondDelay_Fractal.png', 'img/2SecondDelay_Fractal.png', 'coin.png', 'img/12SecondDelay_Fractal.png']
};

timeline.push(preloadTempDiscrim);

timeline.push(preloadIntervalProd);

timeline.push(preloadTempDiscoun);

let totalPointsTempDiscoun = 0;
let trialNumberTD = 1; // temporal discounting trial number
let trialNumberIP = 1; // interval production trial number 

function getBlockPoints(blockType) {
  // Filter trials by the specified block type
  const trials = jsPsych.data.get().filter({phase: 'response', block_type: blockType});
  return trials.select('points').sum();
}


function generateIntervalProdStimuli(blockType = 1) {
  const stimuli = [];
  
  const delays = [2, 4, 8, 12, 16];
  
  for (let delayLength of delays) {
    stimuli.push({
      delayLen: delayLength,
      block_type: blockType
    });
  }
  
  return stimuli;
}

// function to generate stimuli for delay training (just catch trials)
function generateDelayTrainingStimuli() {
  const stimuli = [];
  
  const delays = [2, 4, 8, 12, 16];
  
  // generating catch condition 1 (delay vs delay)
  for (let leftDelay of delays) {
    for (let rightDelay of delays) {
      if (leftDelay !== rightDelay) {
        stimuli.push({
          coinStim: `<img src="img/coin.png" />`,
          left_stim: `<img src="img/${leftDelay}SecondDelay_Fractal.png" />`,
          l_d: leftDelay,
          l_a: 12,
          right_stim: `<img src="img/${rightDelay}SecondDelay_Fractal.png" />`,
          r_d: rightDelay,
          r_a: 12,
          block_type: 3,
          catchCond: 1
        });
      }
    }
  }
  
return stimuli;
}  

// function to generate stimuli for IA training (just catch trials)
function generateIATrainingStimuli() {
  const stimuli = [];
  
  const immediateAmounts = [2, 4, 6, 8];
  
  // generating catch condition 2 (immediate amount vs immediate amount)
  for (let leftAmount of immediateAmounts) {
    for (let rightAmount of immediateAmounts) {
      if (leftAmount !== rightAmount) {
        stimuli.push({
          coinStim: `<img src="img/coin.png" />`,
          left_stim: `<img src="img/${leftAmount}1PercentGreen_IA.png" />`,
          l_d: 1,
          l_a: leftAmount,
          right_stim: `<img src="img/${rightAmount}1PercentGreen_IA.png" />`,
          r_d: 1,
          r_a: rightAmount,
          block_type: 3,
          catchCond: 2
        });
      }
    }
  }
  
return stimuli;
}


// function to generate main task stimuli (adding the temporal discounting trials)
function generateTempDiscounTestingStimuli() {
  const stimuli = [];
  
  const delays = [2,4,8,12,16];
  const immediateAmounts = [2,4,6,8];
  
  const choiceConfigurations = [0,1]; // making counterbalanced choices for the TD trials 
  
  for (let delay of delays) {
      for (let amount of immediateAmounts) {
          for (let config of choiceConfigurations) {
            if (config === 0) { // config of 0 means delay is on left and immediate amount is on right
              stimuli.push({
                coinStim: `<img src="img/coin.png" />`,
                left_stim: `<img src="img/${delay}SecondDelay_Fractal.png" />`,
                l_a: 12,
                l_d: delay,
                right_stim: `<img src="img/${amount}1PercentGreen_IA.png" />`,
                r_a: amount,
                r_d: 1,
                block_type: 4,
                catchCond: 0
              });
            }
            else { // config of 1 means immediate amount is on left and delay is on right
              stimuli.push({
                coinStim: `<img src="img/coin.png" />`,
                left_stim: `<img src="img/${amount}1PercentGreen_IA.png" />`,
                l_a: amount,
                l_d: 1,
                right_stim: `<img src="img/${delay}SecondDelay_Fractal.png" />`,
                r_a: 12,
                r_d: delay,
                block_type: 4,
                catchCond: 0
              });
            
          }
      }
    }
  }
  
  // generating catch condition 1 (delay vs delay)
  for (let leftDelay of delays) {
    for (let rightDelay of delays) {
      if (leftDelay !== rightDelay) {
        stimuli.push({
          coinStim: `<img src="img/coin.png" />`,
          left_stim: `<img src="img/${leftDelay}SecondDelay_Fractal.png" />`,
          l_d: leftDelay,
          l_a: 12,
          right_stim: `<img src="img/${rightDelay}SecondDelay_Fractal.png" />`,
          r_d: rightDelay,
          r_a: 12,
          block_type: 4,
          catchCond: 1
        });
      }
    }
  }
  
  // generating catch condition 2 (immediate amount vs immediate amount)
  for (let leftAmount of immediateAmounts) {
    for (let rightAmount of immediateAmounts) {
      if (leftAmount !== rightAmount) {
        stimuli.push({
          coinStim: `<img src="img/coin.png" />`,
          left_stim: `<img src="img/${leftAmount}1PercentGreen_IA.png" />`,
          l_d: 1,
          l_a: leftAmount,
          right_stim: `<img src="img/${rightAmount}1PercentGreen_IA.png" />`,
          r_d: 1,
          r_a: rightAmount,
          block_type: 4,
          catchCond: 2
        });
      }
    }
  }
  
  return stimuli;
}

/* block type organizer: 
interval prod warmup: 1, interval prod task: 2
 delay training + reward training: 3, temp discount test: 4 */

// create interval prod stimuli 
const intervalProdStimuliWarmup = generateIntervalProdStimuli(); // default is block_type = 1

const intervalProdStimuliMain = generateIntervalProdStimuli(2);

// now make those delay training stimuli
const delayTrainStimuli = generateDelayTrainingStimuli();

// now for the IA training stimuli
const rewardTrainStimuli = generateIATrainingStimuli();

// create that good old main task stimuli
const tempDiscounStimuli = generateTempDiscounTestingStimuli();

// create blank iti screen for interval production task
const iti_intervalprod_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    const blockType = jsPsych.timelineVariable('block_type', true);
    const trialCounts = {
      1: 5,
      2: 50
    } 
    
    const totalTrials = trialCounts[blockType] ?? 0; // fallback to 0 if undefined
    
    return `
      <div style="position: fixed; top: 40px; left: 0; right: 0; text-align: center; background-color: rgba(255,255,255,0.8); padding: 5px; z-index: 100;">
      <span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberIP}/${totalTrials}</span> </div>
      <div style="height: 400px;"></div>
    `;
  },
  choices: "NO_KEYS",
  trial_duration: 300, 
  data: {
    phase: 'iti'
  },
  on_start: function(trial) {
    const blockType = jsPsych.timelineVariable('block_type', true);
  }
};

// CREATE A BLANK ITI SCREEN
const iti_tempdiscoun_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    const catchCond = jsPsych.timelineVariable('catchCond', true);

    const trialCounts = {
      0: 198,
      1: 20,
      2: 12
    };
    
    const totalTrials = trialCounts[catchCond] ?? 0; // fallback to 0 if undefined

    
    if (jsPsych.timelineVariable('block_type', true) === 3) {
      return ` <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px; ">
        <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span> 
        <span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberTD}/${totalTrials}</span> </div>
      <div style="position: fixed; top: 40px; left: 0; right: 0; text-align: center; background-color: rgba(255,255,255,0.8); padding: 5px; z-index: 100;">
      </div>
      <div style="height: 400px;"></div>
    `;
    }
    else {
      return `
      <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px; ">
          <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span> 
          </div>
      <div style="position: fixed; top: 40px; left: 0; right: 0; text-align: center; background-color: rgba(255,255,255,0.8); padding: 5px; z-index: 100;">
      </div>
      <div style="height: 400px;"></div>
      </div>
      `;
    }
  },
  choices: "NO_KEYS",
  trial_duration: 100, 
  data: {
    phase: 'iti'
  },
  on_start: function(trial) {
    // Show counter during both training and main experiment
    {
      // Get the current block type - pull this from timeline variables
      const blockType = jsPsych.timelineVariable('block_type', true);
    }
  }
};

// create screen to show prompt of when to press button
const prompt_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    const delayIP = jsPsych.timelineVariable('delayLen', true);
    const blockType = jsPsych.timelineVariable('block_type', true);
    
    const trialCounts = {
      1: 5,
      2: 50
    } 
    
    const totalTrials = trialCounts[blockType] ?? 0; // fallback to 0 if undefined
    
    return `
    <div style="position: fixed; top: 40px; left: 0; right: 0; text-align: center; background-color: rgba(255,255,255,0.8); padding: 5px; z-index: 100;">
      <span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberIP}/${totalTrials}</span> </div>
    <div style="text-align: center; font-size: 80px; margin-bottom: 30px;">
    ${delayIP}
    </div>
  <div style="text-align: center; font-size: 14px; margin-bottom: 30px;">
      Press <strong>SPACE</strong> after <strong>${delayIP}</strong> second${delayIP === 1 ? '' : 's'}.
    </div>
    `;
  },
  choices: "NO_KEYS",
  trial_duration: 800,
  data: {
    phase: 'prompt',
  }
};

// let timerAnimationFrameId = null;  // So you can cancel the previous updater if needed

// function to start a timer updater
// function startCountdownTimerUpdater() {
//   const updateTimer = () => {
//     const timeLeft = Math.max(0, Math.ceil((testing_phase_deadline - performance.now()) / 1000));
//     const timerElem = document.getElementById('countdown-timer');
//     if (timerElem) {
//       const minutes = Math.floor(timeLeft / 60);
//       const seconds = timeLeft % 60;
//       const paddedSeconds = seconds.toString().padStart(2, '0');
//       timerElem.innerText = `Time left: ${minutes}:${paddedSeconds}`;
//     }
//     if (timeLeft > 0) {
//       timerAnimationFrameId = requestAnimationFrame(updateTimer);
//     }
//     else {
//       jsPsych.endCurrentTimeline();
//     }
//   };

//   timerAnimationFrameId = requestAnimationFrame(updateTimer);
// }

// create screen to get user input on when they think delay has passed via button press
const intervalProdTrial = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
  const delay = jsPsych.timelineVariable('delayLen', true);  
  const blockType = jsPsych.timelineVariable('block_type', true);
    
    const trialCounts = {
      1: 5,
      2: 50
    } 
    
    const totalTrials = trialCounts[blockType] ?? 0; // fallback to 0 if undefined
    
  return `
  <div style="position: fixed; top: 40px; left: 0; right: 0; text-align: center; background-color: rgba(255,255,255,0.8); padding: 5px; z-index: 100;">
      <span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberIP}/${totalTrials}</span> </div>
    <div class="button-container">
    <div class="delay-label">${delay}</div>  
    <div class="button-base">
      <div id="press-button" class="angled-button"></div>
    </div>
  </div>
  
  <style>
    .button-container {
      width: 200px;
      margin: 100px auto;
      perspective: 800px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .delay-label {
      font-size: 80px;
      margin-bottom: 90px;
    }
    
    .button-base {
      width: 160px;
      height: 30px;
      background: #999;
      border-radius: 50% / 40%;
      box-shadow: inset 0 2px 6px rgba(255,255,255,0.3),
                  inset 0 -2px 6px rgba(0,0,0,0.2);
      position: relative;
      display: flex;
      justify-content: center;
      align-items: flex-end; /* align button to bottom of base */
      padding-bottom: 5px;   /* fine-tunes the vertical overlap */
    }
  
    .angled-button {
      width: 140px;
      height: 80px;
      background: radial-gradient(ellipse at center, #ff4d4d 0%, #cc0000 80%);
      border-radius: 50% / 30%;
      transform: rotateX(25deg);
      box-shadow:
        inset -4px -4px 8px rgba(255,255,255,0.4),
        inset 4px 4px 10px rgba(0,0,0,0.3),
        0 8px 0 #555,
        0 12px 20px rgba(0,0,0,0.4);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      position: relative;
      z-index: 2;
    }
  
    .pressed {
      transform: rotateX(25deg) translateY(6px);
      box-shadow:
        inset -2px -2px 5px rgba(255,255,255,0.3),
        inset 2px 2px 5px rgba(0,0,0,0.4),
        0 3px 0 #444,
        0 6px 15px rgba(0,0,0,0.3);
    }
  </style>
  `
  },
  
  choices: 'NO_KEYS',
  data: {
    phase: 'intervalProdTrial',
    delayLenIP: jsPsych.timelineVariable('delayLen')
  },
  on_load: function() {
    const delaySeconds = Number(jsPsych.timelineVariable('delayLen', true));
    const block = jsPsych.timelineVariable('block_type', true);
    
    const stimulusStartTime = performance.now();
    
    
    const keyHandler = function(e) {
      const now = performance.now();
      const timeSinceStart = now - stimulusStartTime;
  
      if (e.code === 'Space' && !e.repeat && timeSinceStart >= 200) {
        const btn = document.getElementById('press-button');
        if (btn) {
          btn.classList.add('pressed');
        }
        
        const rt = Math.round(timeSinceStart);
        
        // Stop listening after valid press
        window.removeEventListener('keydown', keyHandler);
  
        setTimeout(() => {
          jsPsych.finishTrial({
            rt: rt,
            rt_production: rt,
            stimulus_start_time: stimulusStartTime,
            trial_num_intProd: trialNumberIP,
            block_type: block
          });
        }, 150);
      }
    };
    
  window.addEventListener('keydown', keyHandler); // makes it so that if somebody holds SPACE before button appears, they can still press the button
  
  },
  on_finish: function() {
    trialNumberIP++;
  }
};

// create screen to present trials
const choiceTrial = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    var leftStim = jsPsych.timelineVariable('left_stim', true).replace('<img', '<img width="130" height="130"');
    var rightStim = jsPsych.timelineVariable('right_stim', true).replace('<img', '<img width="130" height="130"');
    const catchCond = jsPsych.timelineVariable('catchCond', true);

    const trialCounts = {
      0: 198,
      1: 20,
      2: 12
    };
    
    const totalTrials = trialCounts[catchCond] ?? 0; // fallback to 0 if undefined
    
    if (jsPsych.timelineVariable('block_type', true) === 3) {
      return `
      <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px; ">
          <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span> 
          <span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberTD}/${totalTrials}</span> </div>
      <div style="display: flex; justify-content: space-between; width: 500px; margin: 0 auto;">
        <div style="margin-left: 20px;">${leftStim}</div>
        <div style="margin-right: 20px; margin-bottom: -3000px;">${rightStim}</div>
      </div>
      `;
    }
    else {
      return `
      <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px; ">
          <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span> 
           </div>
      <div style="display: flex; justify-content: space-between; width: 500px; margin: 0 auto;">
        <div style="margin-left: 20px;">${leftStim}</div>
        <div style="margin-right: 20px; margin-bottom: -3000px;">${rightStim}</div>
      </div>
      `;
    }
  },
  
  choices: ['f', 'j'],
  response_ends_trial: true,
  on_start: function (trial) {
    // Record exact time when stimulus is presented
    trial.stimulus_presentation_time = performance.now();
  },
  
  data: function () {
    const block = jsPsych.timelineVariable('block_type', true);
    const catchCond = jsPsych.timelineVariable('catchCond', true);
    let task_phase;
    
    if (block === 3) {
      if (catchCond === 1) {
        task_phase = 'delay_training';
      } else if (catchCond === 2) {
      task_phase = 'reward_training';
      } 
    } 
    else {
      task_phase = 'TDtesting';
    }
    
    const totalTrialCount = jsPsych.data.get()
    .filter({ phase: 'response' })
    .count();
      
    return {
      // Standard trial identification
      participant_id: getParticipantID(),
      phase: 'response',
      task_phase: task_phase,
      block_type: block,
      
      // Trial properties
      r_d: jsPsych.timelineVariable('r_d', true), 
      l_d: jsPsych.timelineVariable('l_d', true), 
      r_a: jsPsych.timelineVariable('r_a', true), 
      l_a: jsPsych.timelineVariable('l_a', true), 
      catchCond: catchCond,
      
      // Trial counters
      current_trial_num: trialNumberTD,
      total_trial_num: totalTrialCount + 1,
      
      // These will be filled in the on_finish callback
      choice_dir: null,
      chose_best: null,
      best_side: null,
      trial_pointsTempDiscoun: null,
      totalPointsTempDiscoun: null,
      valid_response: null,
      chosen_side: null, // Keep this for selection feedback
    };
  },
  
  on_finish: function (data) {
    console.log("RESPONSE DATA:", data.response);
    const catchCond = jsPsych.timelineVariable('catchCond', true);
    
    // Get the pressed key (in jsPsych 7.2, data.response contains the key)
    const pressedKey = data.response;
    
    // Determine which stimulus was chosen (left or right)
    data.chosen_side = pressedKey === 'f' ? 'left' : 'right';
    console.log("CHOSEN SIDE:", data.chosen_side);
    
    choice_dir = data.chosen_side === 'left' ? -1 : 1; // left side = choice_dir of -1
    
    // Add choice direction (-1 for left, 1 for right)
    data.choice_dir = data.chosen_side === 'left' ? -1 : 1;
    
    // Get the chosen value (used internally)
    const chosen_val = data.chosen_side === 'left' ? 
      jsPsych.timelineVariable('l_a', true) : 
      jsPsych.timelineVariable('r_a', true);
    
    // Get the chosen delay (used internally)
    const chosen_delay = data.chosen_side === 'left' ? 
      jsPsych.timelineVariable('l_d', true) : 
      jsPsych.timelineVariable('r_d', true);  
    
    if (catchCond > 0) {
      if (jsPsych.timelineVariable('l_a', true) === jsPsych.timelineVariable('r_a', true)) {
      data.best_side = data.l_d < data.r_d ? 'left' : 'right';
      }
      else if (catchCond === 2) {
      data.best_side = data.l_a > data.r_a ? 'left' : 'right';
      }
    }
    
    // Only evaluate chose_best on catch trials during testing
    if (catchCond > 0) {
      data.chose_best = data.chosen_side === data.best_side ? 1 : 0;
      
      const allResponseTrials = jsPsych.data.get().filter({ phase: 'response' }).values();
      const currentIndex = allResponseTrials.length;
      
      // Slice to get only previous trials (excluding current one)
      const priorTrials = allResponseTrials.slice(0, currentIndex);
      
      // separating catch trials based on whether they are for LL or SS
      const priorCatchTrials = priorTrials.filter(t => t.catchCond !== 0 && typeof t.catchCond !== 'undefined');

      
      const correctCount = priorCatchTrials.filter(t => t.chose_best === 1).length;
      
      const totalCount = priorCatchTrials.length;
    }
    
    
    // Set points based on chosen value
    data.trial_pointsTempDiscoun = chosen_val;
    
    // Track cumulative points
    data.totalPointsTempDiscoun;
    
    // Add response validity flag
    data.valid_response = data.rt > 200 && data.rt < 8000; // Example thresholds
  }
};

// creates variable to determine if participant should repeat training
let shouldRepeatDelayTraining = false; 
let shouldRepeatRewardTraining = false;

// function to evaluate training accuracy in order to prevent progression if low accuracy
const evaluateTrainingPerformance = {
  type: jsPsychCallFunction,
  func: function() {

    // Get delay training trials (temporal discounting)
    const delayTrainingTrials = jsPsych.data.get().filter({ 
      phase: 'response',
      task_phase: 'delay_training'
    }).last(20);
    
    // Get reward training trials (temporal discounting)  
    const rewardTrainingTrials = jsPsych.data.get().filter({ 
      phase: 'response',
      task_phase: 'reward_training'
    }).last(12);
    
    // Calculate delay training performance
    let delayAccuracy = 0;
    if (delayTrainingTrials.count() > 0) {
      const delayCorrect = delayTrainingTrials.filter({ chose_best: 1 }).count();
      delayAccuracy = delayCorrect / delayTrainingTrials.count();
    }
    
    // Calculate reward training performance
    let rewardAccuracy = 0;
    if (rewardTrainingTrials.count() > 0) {
      const rewardCorrect = rewardTrainingTrials.filter({ chose_best: 1 }).count();
      rewardAccuracy = rewardCorrect / rewardTrainingTrials.count();
    }
    
    shouldRepeatRewardTraining = rewardAccuracy >= 0.75 ? false : true;
    shouldRepeatDelayTraining = delayAccuracy >= 0.75 ? false : true;
    
    if (delayTrainingTrials.count() === 0) {
      shouldRepeatDelayTraining = false;
    }
    else if (rewardTrainingTrials.count() === 0) {
      shouldRepeatRewardTraining = false;
    }
    // round delayAccuracy and rewardAccuracy to the nearest hundredth
    // Add properties to the data
    jsPsych.data.addProperties({ 
      delay_training_accuracy: delayAccuracy,
      reward_training_accuracy: rewardAccuracy,
      overall_training_accuracy: (delayAccuracy + rewardAccuracy) / 2,
      repeat_delayTraining: shouldRepeatDelayTraining, 
      repeat_rewardTraining: shouldRepeatRewardTraining, 
    });
    
  }
};

// GET THAT TIMER WORKIN
let totalTime = 20 * 60 * 1000;
let elapsedTime = 0;
let timerStart = null;
let tdBlockCount = 1;

const startTempDiscounTimer = {
  type: jsPsychCallFunction,
  func: function () {
    timerStart = performance.now();
  }
};

let shouldRepeatTesting = false;

const evaluateTimeRemaining = {
  type: jsPsychCallFunction,
  func: function() {
    const now = performance.now();
    elapsedTime += now - timerStart; // Add time since last resume
    const timeLeft = totalTime - elapsedTime;

    shouldRepeatTesting = timeLeft > 5 * 60 * 1000;
    
    jsPsych.data.addProperties({
      repeatTesting: shouldRepeatTesting,
      timeLeft: timeLeft,
      elapsedTime: elapsedTime,
      // add repetition counter
    })
  }
};

let pauseTimes = [];

const pauseTimer = {
  type: jsPsychCallFunction,
  func: function() {
    const pauseTime = performance.now();
    pauseTimes.push(pauseTime);
    
    
    jsPsych.data.addDataToLastTrial({
      pause_time: pauseTime,
      elapseTimeAtPause: elapsedTime
    })
  }
};

const resumeTimer = {
  type: jsPsychCallFunction,
  func: function() {
    timerStart = performance.now(); // reset start timestamp
    
    jsPsych.data.addProperties({
      td_block_count: tdBlockCount
    })
    
    tdBlockCount++;
  }
}
// SELECTION FEEDBACK SCREEN
const selection_feedback_tempdiscoun = {
  type: jsPsychHtmlKeyboardResponse,
  choices: "NO_KEYS",

  trial_duration: function() {
    const last_trial = jsPsych.data.get().last(1).values()[0];
    const chosen_side = last_trial.chosen_side;
    const chosen_delay = chosen_side === 'left' ? 
    jsPsych.timelineVariable('l_d', true) : 
    jsPsych.timelineVariable('r_d', true); 
    return chosen_delay * 1000;
  },
  data: {
    phase: 'selection_feedback',
  },
  stimulus: function () {
    // Get the EXACT chosen_side from the last trial
    const last_trial = jsPsych.data.get().last(1).values()[0];
    const chosen_side = last_trial.chosen_side; // This should be 'left' for 'f' key
   
   // assigning values just like the choiceTrial
    var leftStim = jsPsych.timelineVariable('left_stim', true).replace('<img', '<img width="130" height="130"');
    var rightStim = jsPsych.timelineVariable('right_stim', true).replace('<img', '<img width="130" height="130"');
    const catchCond = jsPsych.timelineVariable('catchCond', true);

    const trialCounts = {
      0: 198,
      1: 20,
      2: 12
    };
    
    const totalTrials = trialCounts[catchCond] ?? 0; // fallback to 0 if undefined
    
    let html = `
    <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px;">
        <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span>
    `;

    if (jsPsych.timelineVariable('block_type', true) == 3) {
      html += `<span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberTD}/${totalTrials}</span>`;
    } 

    html += `</div>`;
    
    // Main feedback row
    html += `<div style="display: flex; justify-content: space-between; width: 500px; margin: 0 auto;">`;
    
    if (chosen_side === 'left') {
      html += `
        <div style="margin-left: 20px; padding: 10px; outline: 6px solid black; border-radius: 10px; box-sizing: content-box;">
          ${leftStim}
        </div>
        <div style="margin-right: 20px;">
          ${rightStim}
        </div>`;
    } else {
      html += `
        <div style="margin-left: 20px;">
          ${leftStim}
        </div>
        <div style="margin-right: 20px; padding: 10px; outline: 6px solid black; border-radius: 10px; box-sizing: content-box;">
          ${rightStim}
        </div>`;
    }
    
    html += `</div>`;
    return html;
  }, 
  on_finish: function(data) {
    // Get the previous trial's data (the choice trial)
    const last_trial = jsPsych.data.get().last(2).values()[0]; 
  
    const chosen_side = last_trial.chosen_side;
    const chosen_val = chosen_side === 'left' ? last_trial.l_a : last_trial.r_a;
  
    data.chosen_side = chosen_side;
    data.trial_pointsTempDiscoun = chosen_val;
  
    const lastPoints = chosen_val || 0;
    totalPointsTempDiscoun += lastPoints;
    data.totalPointsTempDiscoun = totalPointsTempDiscoun;
  }
};

// screen to show points
const reward_feedback_tempdiscoun = {  
  type: jsPsychHtmlKeyboardResponse,
  choices: "NO_KEYS",
  trial_duration: 2000,
  data: {
    phase: 'reward_feedback',
  },
  stimulus: function () {
    const last_trial = jsPsych.data.get().last(2).values()[0]; // Get the choice trial (2 trials back)
    const points = last_trial.trial_pointsTempDiscoun; // Use the updated field name
    const chosen_side = last_trial.chosen_side; // This should be 'left' for 'f' key
   
    const leftStim = jsPsych.timelineVariable('left_stim', true);
    const rightStim = jsPsych.timelineVariable('right_stim', true);
    //const coinStim = jsPsych.timelineVariable('coinStim', true).replace('<img', '<img width="50" height="50"');
    // const coinHTML = coinStim.repeat(points);
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = jsPsych.timelineVariable('coinStim', true);
    const coinSrc = tempDiv.querySelector('img').src;
    const catchCond = jsPsych.timelineVariable('catchCond', true);

    const trialCounts = {
      0: 198,
      1: 20,
      2: 12
    };
    
    const totalTrials = trialCounts[catchCond] ?? 0; // fallback to 0 if undefined
    
    let coinHTML = "";
    let mainHTML = `
    <div style="position: fixed; top: 40px; left: 0; right: 0; z-index: 100; display: flex; flex-direction: column; align-items: center; background-color: rgba(255,255,255,0.8); padding: 5px;">
        <span style="font-size: 20px; font-weight: bold;">Total Coins: ${totalPointsTempDiscoun}</span>
    `;

    if (jsPsych.timelineVariable('block_type', true) == 3) {
      mainHTML += `<span style="font-size: 20px; font-weight: bold;">Trial Number: ${trialNumberTD}/${totalTrials}</span>`;
    } 
    
    // Choose class based on points
    let animationClass = "";
    let extraStyles = "";
    let sparkleEffect = '';
    
    
    if (points === 2) {
      animationClass = "fadeIn-coin";
      extraStyles = `
        @keyframes fadeIn {
          to {
            opacity: 1;
          }
        }
        .fadeIn-coin {
          opacity: 0;
          animation: fadeIn 1s ease forwards;
        }
      `;
    } else if (points === 4) {
      animationClass = "bounce-coin";
      extraStyles = `
        @keyframes bounce {
          0% { transform: translateY(0); }
          50% { transform: translateY(-15px); }
          100% { transform: translateY(0); }
        }
        .bounce-coin {
          animation: bounce 1.2s ease;
        }
      `;
    } else if (points === 6) {
      animationClass = "spin-coin";
      extraStyles = `
        @keyframes spin {
          from { transform: rotate(0deg); opacity: 0; }
          to { transform: rotate(360deg); opacity: 1; }
        }
        .spin-coin {
          opacity: 0;
          animation: spin 1.1s ease-out forwards;
        }
      `;
    } else if (points === 8) {
      animationClass = "fadeUp-bounce-glow-coin";
      extraStyles = `
        @keyframes fadeUpBounceGlow {
          0% {
            opacity: 0;
            transform: translateY(30px) scale(0.8);
            box-shadow: 0 0 0px #228B22;
          }
          50% {
            opacity: 1;
            transform: translateY(-10px) scale(1.1);
            box-shadow: 0 0 10px #228B22;
          }
          100% {
            opacity: 1;
            transform: translateY(0) scale(1);
            box-shadow: 0 0 5px #228B22;
          }
        }
    
        .fadeUp-bounce-glow-coin {
          opacity: 0;
          transform: translateY(30px);
          animation: fadeUpBounceGlow 1.2s ease-out forwards;
          border-radius: 50%;
        }
      `;
  } else if (points === 12) {
    animationClass = "fadeUp-glow-coin";
    extraStyles = `
      @keyframes fadeUpGlow {
        0% {
          opacity: 0;
          transform: translateY(20px) scale(0.9);
          box-shadow: 0 0 0px #00CED1;
        }
        50% {
          opacity: 1;
          transform: translateY(10px) scale(1.05);
          box-shadow: 0 0 15px #00CED1;
        }
        100% {
          opacity: 1;
          transform: translateY(0) scale(1);
          box-shadow: 0 0 10px #00CED1;
        }
      }
  
      .fadeUp-glow-coin {
        opacity: 0;
        transform: translateY(20px);
        animation: fadeUpGlow 0.8s ease-out forwards;
        border-radius: 50%;
      }
    `;
    
  
    // Add confetti burst using canvas-confetti
    setTimeout(() => {
      confetti({
        particleCount: 80,
        spread: 100,
        origin: { y: 0.6 },
        colors: ['#FFD700', '#FFFACD', '#FFEC8B'],
        ticks: 90,         // shorter lifetime
        gravity: 1.1       // fall faster
      });
    }, 300);
    }
    
    // Generate the coin HTML with delay
    for (let i = 0; i < points; i++) {
      coinHTML += `<img src="${coinSrc}" class="${animationClass}" style="animation-delay: ${i * 0.1}s;" width="50" height="50">`;
    }
    
    
    
    return `
    ${mainHTML}
    </div>
      <style>
        .coin-container {
          display: flex;
          justify-content: center;
          gap: 8px;
          flex-wrap: wrap;
          margin-top: 10px;
        }
        ${extraStyles}
      </style>
      <div style="font-size: 48px; text-align:center;">
        <p>You earned ${points} coins!</p>
        <div class="coin-container">${coinHTML}</div>
      </div>
        ${sparkleEffect || ''}
    `;
  },
  on_finish: function() {
    trialNumberTD++;
  }
};

// resets the TD trial number
const resetTrialNumberTD = {
  type: jsPsychCallFunction,
  func: function() {
    trialNumberTD = 1;
  }
};

const resetTrialNumberIP = {
  type: jsPsychCallFunction,
  func: function() {
    trialNumberIP = 1;
  }
};

const resetTotalPoints = {
  type: jsPsychCallFunction,
  func: function() {
    totalPointsTempDiscoun = 0;
  }
}

// Combined welcome with embedded consent form
const welcome_and_consent = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
    <div style="text-align: center; margin-bottom: 20px;">
      <img src="img/ut_neuro_logo.png" alt="UT Austin Neuroscience Department Logo" style="max-width: 250px; height: auto;">
    </div>
   
    <h1>Time Perception and Patience</h1>
    <div style="border: 1px solid #ccc; background-color: #f9f9f9; padding: 15px; margin: 20px 0; border-radius: 5px;">
      <h3 style="text-align: center;">Consent to Participate in Research</h3>
     
      <p style="text-align: center;">This study involves:</p>
      <ol style="text-align: left; padding-left: 40px;">
        <li><strong>Demographic Information:</strong> Brief questions about your age, gender, and education (less than 1 minute)</li>
        <li><strong>Interval Production Phase:</strong> An interval production task involving pressing a button after a given number of time (approx 5 minutes) </li>
        <li><strong>Temporal Discounting Phase:</strong> A temporal discounting task involving choosing between smaller sooner options and later larger options (approx 25 minutes)  </li>
      </ol>
      <p style="text-align: center;">Total participation time: approximately 30 minutes</p>
     
      <div style="border: 1px solid #ddd; padding: 10px; margin: 15px 0; background-color: white;">
        <p><strong>Anonymity and Data Usage:</strong> Your participation is completely anonymous and no personally identifying information is collected.</p>
       
        <p><strong>Voluntary Participation:</strong> Your participation is voluntary. You may withdraw at any time without penalty by closing this browser tab.</p>
       
        <p><strong>IRB Approval:</strong> This study has been reviewed and approved by The University of Texas at Austin Institutional Review Board.</p>
      </div>
    </div>
   
    <p>By clicking "I Consent", you confirm that you have read the above information and voluntarily agree to participate.</p>
  `,
    choices: ["I Consent", "I Do Not Consent"],
    data: {
        phase: 'consent',
        task_phase: 'consent'
    },
    on_finish: function (data) {
        // If participant does not consent, end the experiment
        if (data.response == 1) {
            jsPsych.endExperiment('Thank you for your interest. The experiment has been terminated as consent was not provided.');
        }
    }
};

// COLLECT DEMOGRAPHICS WITH A DROPDOWN MENU
const demographics_combined = {
    type: jsPsychSurveyHtmlForm,
    preamble: `
    <h2>Demographic Information</h2>
    <p>Please answer the following questions about yourself.</p>
  `,
    html: `
    <div class="survey-item">
      <label for="age">What is your age?</label>
      <select id="age" name="age" required>
        <option value="" selected disabled>Select an option</option>
        <option value="18-24">18-24</option>
        <option value="25-34">25-34</option>
        <option value="35-44">35-44</option>
        <option value="45-54">45-54</option>
        <option value="55-64">55-64</option>
        <option value="65-74">65-74</option>
        <option value="75 or older">75 or older</option>
        <option value="Prefer not to answer">Prefer not to answer</option>
      </select>
    </div>
   
    <div class="survey-item">
      <label for="gender">What is your gender?</label>
      <select id="gender" name="gender" required>
        <option value="" selected disabled>Select an option</option>
        <option value="Male">Male</option>
        <option value="Female">Female</option>
        <option value="Non-binary">Non-binary</option>
        <option value="Other">Other</option>
        <option value="Prefer not to answer">Prefer not to answer</option>
      </select>
    </div>
   
    <div class="survey-item">
      <label for="education">What is your highest level of education?</label>
      <select id="education" name="education" required>
        <option value="" selected disabled>Select an option</option>
        <option value="Less than high school">Less than high school</option>
        <option value="High school graduate">High school graduate</option>
        <option value="Some college">Some college</option>
        <option value="Bachelor's degree">Bachelor's degree</option>
        <option value="Master's degree">Master's degree</option>
        <option value="Doctoral degree">Doctoral degree</option>
        <option value="Prefer not to answer">Prefer not to answer</option>
      </select>
    </div>
  `,
    button_label: 'Continue',
    data: {
        phase: 'demographics',
        task_phase: 'demographics'
    },
    // Add some basic styling to make the dropdowns look nicer
    css: `
    .survey-item {
      margin-bottom: 20px;
    }
   
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
    }
   
    select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 16px;
    }
  `
};

// screen that asks for consent to not use a timer
const timer_consent = {
  type: jsPsychHtmlButtonResponse,
  stimulus: `
  <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
  <h2>Consent to Not Use a Timing Aid</h2>
   
    <p>The following experiment is dependent on individual differences in the perception of time.</p>
   
    <p>As a result, the use of a time-keeping device, such as a timer or stopwatch, or device that can be used as a distraction, such as a phone, is prohibited.</p>
   
    <p>By clicking "I Consent", you confirm that you have read the above information and agree to not use a secondary device that can be used to keep time or distract oneself. </p>
   
  `,
  choices: ["I Consent", "I Do Not Consent"],
    data: {
        phase: 'timer_consent',
        task_phase: 'timer_consent'
    },
    on_finish: function (data) {
        // If participant does not consent, end the experiment
        if (data.response == 1) {
            jsPsych.endExperiment('Thank you for your interest. The experiment has been terminated as consent was not provided.');
        }
    }
}

const combined_intervalprod_instructions = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <h1>Welcome to the Interval Production Task!</h1>
   
    <div style="border: 1px solid #ccc; background-color: #f9f9f9; padding: 15px; margin: 20px 0; border-radius: 5px;">
    <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
      <p>In this task, you will press the space bar after you think a certain amount of time has passed. </p>

      <div style="border: 1px solid #ddd; padding: 5px; margin: 15px 0; background-color: white;">
        <p style="text-align: center;"><strong>On each trial, you will:</strong></p>
        <ol style="text-align: left; padding-left: 40px;">
          <li>Be shown a prompt. </li>
          <li>After the prompt, a button will appear, which is when you should begin counting.</li>
          <li>Press the SPACE bar after you think the time shown in the prompt is finished.</li>
        </ol>
       
        <div style="text-align: center; margin: 20px;">
          <span style="display: inline-block; width: 700px; text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #f5f5f5;">
            <strong>Important</strong><br>Rapid, "button-mashing" will result in a rejection of your work.
          </span>
        </div>
      </div>
   
    <p>You will begin with a few training trials to familiarize yourself with the task. </p>
    <p>Press any key to continue.</p>
  `,
    post_trial_gap: 500
};

const intervalprodwarmup_Info = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
    <h2>Training Phase</h2>
   
    <p>You will begin by completing a few trials to familiarize yourself with the task. </p>
    <strong>Remember:</strong> 
    <div style="text-align: left; margin-top: 0px;">
    <li>Start counting as soon as you see the button.</li>
    <li>Press SPACE when you think the time shown is finished.</li></div>
   
    <p>Press any key to continue with the training.</p>
  `
};

const intervalprodwarmup_Debrief = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
    <h2>Training Complete</h2>
   
    <p>Great job! You have completed the training for the interval production task. 
    The main task will be identical to this training.</p>
   
    <p>Press any key to continue with the main task.</p>
  `
};

// intervalProd debrief screen
const intervalprod_Debrief = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <h2>Interval Production Phase Complete</h2>
   
    <p>Great job! You have completed the interval production task.</p>
   
    <p>Press any key to continue with the rest of the experiment.</p>
  `
};

// define the instructions
const combined_tempdiscoun_instructions = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <h1>Welcome to the Temporal Discounting Task!</h1>
   
    <div style="border: 1px solid #ccc; background-color: #f9f9f9; padding: 15px; margin: 20px 0; border-radius: 5px;">
      <p>Your goal is to maximize your points. </p>
      <p>You will choose between two options that have associated delays and rewards. </p>
      
     
      <div style="border: 1px solid #ddd; padding: 5px; margin: 15px 0; background-color: white;">
        <p style="text-align: center;"><strong>Trial Sequence:</strong></p>
        <ol style="text-align: left; padding-left: 40px;">
          <li>You are shown two options that either correspond to reward or delay</li>
          <li>Choose the option you value more</li>
          <li>Make your choice using the keyboard:</li>
        </ol>
       
        <div style="text-align: center; margin: 20px;">
          <span style="display: inline-block; width: 150px; text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #f5f5f5;">
            <strong>F key</strong><br>for LEFT option
          </span>
          <span style="display: inline-block; width: 30px;"></span>
          <span style="display: inline-block; width: 150px; text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background-color: #f5f5f5;">
            <strong>J key</strong><br>for RIGHT option
          </span>
        </div>
      </div>

      <p>You will begin with training trials to familiarize yourself with the task.</p>
      <p>In the training phase, you will learn the values associated with each option.</p>
    </div>
   
    <p>Press any key to continue.</p>
  `,
    post_trial_gap: 500
};

// delay training info screen
const delay_training_info_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
  <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
    <h2>Delay Training Phase</h2>
    
    <p>You will now complete a set of training trials focusing on learning the delays associated with different options.</p>
    <p>These options all pay the same reward of +12 points.</p>
    <p>However, each option requires you to wait a different amount of time to receive the reward. </p>
    
    <p>On each choice, the best option is the one with a shorter delay.</p>
    <p>Your goal is to learn the delays associated with the choice options and pick the shortest one.</p>
    <p>You must achieve at least 75% accuracy (choosing the shorter delay) to proceed to the main experiment.</p>
      
    
    <p>Remember: Press <strong>F</strong> to select the left option and <strong>J</strong> to select the right option.</p>  
    
    <p>Press any key to begin the delay training.</p>
  `
};

// reward training info screen
const reward_training_info_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
  <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
    <h2>Reward Training Phase</h2>
    
    <p>You will now complete a set of training trials focusing on learning the rewards associated with different options.</p>
    <p>These options do not have delays between choosing and receiving the reward. </p>
    <p>However, each option pays a different amount of reward. 
    
    <p>Your task is to learn the rewards associated with each option.</p>
    <p>You must achieve at least 75% accuracy (choosing the greater reward) to proceed to the main experiment.</p>
    
    <p>Remember: Press <strong>F</strong> to select the left option and <strong>J</strong> to select the right option.</p>
    
    <p>Press any key to begin the reward training.</p>
  `
};

const trainingSSFeedbackMessage = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    if (shouldRepeatRewardTraining === true) {
      return `
        <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.6;">
          <p style="color: red; font-size: 30px; margin-bottom: 10px"><strong>You didn't reach 75% accuracy. Try again!</strong></p>
          <p style="font-size: 20px; margin-top: 0;"><strong>Remember:</strong> choose the option with the most coins!</p>
          <p style="font-size: 20px; margin-top: 4px">Press any key to retry the training block.</p>
        </div>
      `;
    } else {
      return `
        <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.6;">
        <p style="color: green; font-size: 40px; margin-bottom: 10px;"><strong>Great job!</strong></p>
        <p style="font-size: 20px; margin-top: 0;">You achieved at least 75% accuracy and can now proceed to the rest of the experiment.</p>
        <p style="font-size: 20px; margin-top: 4px;">Press any key to continue.</p>
      </div>
      `;
    }
  },
  data: function() {
    return {
      phase: shouldRepeatRewardTraining ? 'SStraining_retry' : 'SStraining_success'
    };
  }
};

const trainingLLFeedbackMessage = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    if (shouldRepeatDelayTraining === true) {
      return `
        <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.6;">
          <p style="color: red; font-size: 40px; margin-bottom: 10px"><strong>You didn't reach 75% accuracy. Try again!</strong></p>
          <p style="font-size: 20px; margin-top: 0;"><strong>Remember:</strong> choose the option with the shortest delay!</p>
          <p style="font-size: 20px; margin-top: 4px">Press any key to retry the training block.</p>
        </div>
      `;
    } else {
      return `
        <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.6;">
        <p style="color: green; font-size: 40px; margin-bottom: 10px;"><strong>Great job!</strong></p>
        <p style="font-size: 20px; margin-top: 0;">You achieved at least 75% accuracy and can now proceed to the rest of the experiment.</p>
        <p style="font-size: 20px; margin-top: 4px;">Press any key to continue.</p>
      </div>
      `;
    }
  },
  data: function() {
    return {
      phase: shouldRepeatDelayTraining ? 'LLtraining_retry' : 'LLtraining_success'
    };
  }
};


// main experiment start screen 
const MainExperiment_tempdiscoun_StartScreen = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
    <h2>Main Experiment Phase</h2>
   
    <p>Great job! You have completed the training phases.</p>
   
    <p>You will now have 20 minutes to complete the main experiment. In this phase, in addition to choosing between two smaller, sooner (SS) options and between two later, larger (LL) options, you will compare
    SS options vs LL options. Your goal is to maximize your points. Your points earned from the training phase will reset.</p>
   
    <p>Try to use what you learned in the training phase to get as many points as you can in 20 minutes. You'll periodically get breaks.</p>
   
    <p>Press any key to begin the main experiment.</p>
  `
};



const Debrief_at_End = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function () {
        return `
        <div style="max-width: 1000px; margin: 0 auto; text-align: center; line-height: 1.5;">
        <h2>Experiment Complete</h2>
        
        <p>Thank you for participating in our time perception and patience study!</p>
        
        <p>This study helps us examine the relationship between the speed of someone's internal clock and their willingness
        to delay gratification.</p>
        
        <p><strong>Press any key to close the experiment.</strong></p>`;
    },
    post_trial_gap: 1000
}; // end of debrief screen


const intervalProdBlock = {
  timeline: [iti_intervalprod_screen, prompt_screen, intervalProdTrial],
  timeline_variables: intervalProdStimuliMain,
  randomize_order: true,
  repetitions: 10
};

const intervalProdWarmup = {
  timeline: [iti_intervalprod_screen, prompt_screen, intervalProdTrial],
  timeline_variables: intervalProdStimuliWarmup,
  randomize_order: true,
  repetitions: 1
}

const delay_train_procedure = {
    timeline: [iti_tempdiscoun_screen, choiceTrial, selection_feedback_tempdiscoun, reward_feedback_tempdiscoun],
    timeline_variables: delayTrainStimuli,
    randomize_order: true,
    repetitions: 1
};

const delay_trainingLoop = {
  timeline: [delay_train_procedure, evaluateTrainingPerformance, trainingLLFeedbackMessage, resetTrialNumberTD],
  loop_function: function() {
    return shouldRepeatDelayTraining;
  }
};

const reward_train_procedure = {
    timeline: [iti_tempdiscoun_screen, choiceTrial, selection_feedback_tempdiscoun, reward_feedback_tempdiscoun],
    timeline_variables: rewardTrainStimuli,
    randomize_order: true,
    repetitions: 1
};

const reward_trainingLoop = {
  timeline: [reward_train_procedure, evaluateTrainingPerformance, trainingSSFeedbackMessage, resetTrialNumberTD],
  loop_function: function() {
    return shouldRepeatRewardTraining;
  }
};

const mainTestingTrials = {
  timeline: [iti_tempdiscoun_screen, choiceTrial, selection_feedback_tempdiscoun, reward_feedback_tempdiscoun],
  timeline_variables: tempDiscounStimuli,
  randomize_order: true,
  repetitions: 1,
}

const breakScreen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function () {
    const timeLeft = totalTime - elapsedTime;
    const minutes = Math.floor(timeLeft / 60000);
    const seconds = Math.floor((timeLeft % 60000) / 1000);
    const paddedSeconds = seconds.toString().padStart(2, '0');
    
    if (shouldRepeatTesting) {
      return `
        <div style="text-align: center;">
          <h2>Take a short break</h2>
          <p>You have <strong>${minutes}:${paddedSeconds}</strong> remaining in the main task.</p>
          <p>Press any key to begin the next block.</p>
        </div>
      `;
    }
    else {
      return ``;
    }
  },
  choices: function() {
    return shouldRepeatTesting ? "ALL_KEYS" : "NO_KEYS"; // does not require button press if participant is finished with experiment
  },
  trial_duration: function() {
    return shouldRepeatTesting ? null : 1; // 1ms blank screen if skipping
  }
};


const mainTDLoop = {
  timeline: [
    resumeTimer,
    mainTestingTrials,
    evaluateTimeRemaining,
    pauseTimer,
    breakScreen
  ],
  loop_function: function () {
    return shouldRepeatTesting; 
  }
};

// Add components to the timeline
timeline.push(welcome_and_consent);
timeline.push(demographics_combined);
timeline.push(timer_consent);

timeline.push(combined_intervalprod_instructions);
timeline.push(intervalprodwarmup_Info);
timeline.push(intervalProdWarmup);
timeline.push(intervalprodwarmup_Debrief);
timeline.push(resetTrialNumberIP);
timeline.push(intervalProdBlock);
timeline.push(intervalprod_Debrief);


timeline.push(combined_tempdiscoun_instructions);

// // randomize training order 
if (Math.random() > .5) {
    timeline.push(delay_training_info_screen);
    timeline.push(delay_trainingLoop);
    
    timeline.push(resetTrialNumberTD);
    timeline.push(reward_training_info_screen);
    timeline.push(reward_trainingLoop);
} else {
    timeline.push(reward_training_info_screen);
    timeline.push(reward_trainingLoop);
    
    timeline.push(resetTrialNumberTD);
    timeline.push(delay_training_info_screen);
    timeline.push(delay_trainingLoop);
}

timeline.push(resetTrialNumberTD);
timeline.push(resetTotalPoints);
timeline.push(MainExperiment_tempdiscoun_StartScreen);
timeline.push(startTempDiscounTimer); // initialize timer

timeline.push(mainTDLoop);



timeline.push(Debrief_at_End);

// start the experiment
loadConfettiLibrary(() => {
  jsPsych.run(timeline);
});